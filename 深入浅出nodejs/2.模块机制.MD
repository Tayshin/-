#模块机制
##JS的缺点
 1. 没有模块系统
 2. 标准库少
 3. 没有标准接口
 4. 缺少包管理系统
 
##CommonJS
 **1.模块引用**

    var math = require();
    console.log(math.add());
    
 **2.模块定义**
 上下文提供exports对象导出当前模块方法或变量，module模块表示自身，exports是module的属性

    //math.js
    exports.add = function(){
        //...
    }
    
 **3.模块标志**
驼峰命名法

##模块实现

1.**引用步骤**
>路径分析
文件定位
编译执行


>**核心模块**在node源码编译时，编译进二进制文件，进程启动时候，被直接加载进内存，所以省略了路径分析和文件定位
**文件模块**在运行时动态加载，较慢。

2.**加载方式**

2.1*缓存加载*
>缓存优先，node对引入过的模块会缓存编译和执行的对象
核心模块检查优先于文件模块
第一优先级

2.2*模块标识分析*

 - 核心模块：http,fs...
 - .. . 开头的相对路径模块
 - 绝对路径模块
 - 非路径模块

分析**模块路径**：查找当前目录node_modules,之后依次向上（父级）目录下的node_modules目录。
 
分析**拓展名**：不包括拓展名的情况下，按照.js,.node,.json依次尝试，尝试时会调用fs阻塞式判断文件是存在，传递给require的文件带上.node
.json，会加快速度。

2.3*模块编译*

>js调用：直接通过fs模块编译执行
node文件：C/C++编写的拓展文件，通过dlopen加载编译生成的文件，
.json：fs读取，JSON.parse()返回结果
其他拓展名：当作js

每个编译成功的模块都会放在Module._cache上，缓存。

